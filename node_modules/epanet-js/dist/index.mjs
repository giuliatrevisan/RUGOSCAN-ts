var V = Object.defineProperty;
var k = (e, n, r) => n in e ? V(e, n, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[n] = r;
var t = (e, n, r) => k(e, typeof n != "symbol" ? n + "" : n, r);
import $ from "@model-create/epanet-engine";
class Ae {
  constructor() {
    t(this, "_emscriptenModule");
    t(this, "_instance");
    t(this, "_FS");
    this._emscriptenModule = $;
  }
  async loadModule() {
    const n = await this._emscriptenModule();
    this._instance = n, this._FS = n.FS;
  }
  checkEngineLoaded() {
    if (!this._instance)
      throw new Error("EPANET engine not loaded. Call loadModule() first.");
  }
  get isLoaded() {
    return !!this._instance;
  }
  get instance() {
    return this.checkEngineLoaded(), this._instance;
  }
  get FS() {
    return this.checkEngineLoaded(), this._FS;
  }
  get version() {
    const n = this.instance._malloc(4);
    this.instance._EN_getversion(n);
    const r = this.instance.getValue(n, "i32");
    return this.instance._free(n), r;
  }
  getError(n) {
    const r = this.instance._malloc(256);
    this.instance._EN_geterror(n, r, 256);
    const u = this.instance.UTF8ToString(r);
    return this.instance._free(r), u;
  }
  writeFile(n, r) {
    this.FS.writeFile(n, r);
  }
  readFile(n, r) {
    return !r || r === "utf8" ? (r = "utf8", this.FS.readFile(n, {
      encoding: r
    })) : this.FS.readFile(n, {
      encoding: r
    });
  }
}
const h = {
  // EN_createproject is handled manually in constructor
  // EN_getversion is handled manually in version check
  init: {
    wasmFunctionName: "_EN_init",
    inputArgDefs: [
      { typeHint: "string", isStringPtr: !0 },
      // reportFile
      { typeHint: "string", isStringPtr: !0 },
      // binaryFile
      { typeHint: "number" },
      // hydOption (unitsType in C API)
      { typeHint: "number" }
      // qualOption (headlossType in C API)
    ],
    outputArgDefs: []
  },
  open: {
    wasmFunctionName: "_EN_open",
    inputArgDefs: [
      { typeHint: "string", isStringPtr: !0 },
      // inputFile
      { typeHint: "string", isStringPtr: !0 },
      // reportFile
      { typeHint: "string", isStringPtr: !0 }
      // binaryFile
    ],
    outputArgDefs: []
  },
  close: {
    wasmFunctionName: "_EN_close",
    inputArgDefs: [],
    outputArgDefs: []
  },
  addNode: {
    wasmFunctionName: "_EN_addnode",
    inputArgDefs: [
      { typeHint: "string", isStringPtr: !0 },
      // id
      { typeHint: "enum", isStringPtr: !1 }
      // type (NodeType enum)
    ],
    outputArgDefs: [{ name: "index", type: "int" }]
  },
  getCount: {
    wasmFunctionName: "_EN_getcount",
    inputArgDefs: [{ typeHint: "enum" }],
    // countType (CountType enum)
    outputArgDefs: [{ name: "count", type: "int" }]
  },
  getNodeIndex: {
    wasmFunctionName: "_EN_getnodeindex",
    inputArgDefs: [{ typeHint: "string", isStringPtr: !0 }],
    // id string
    outputArgDefs: [{ name: "index", type: "int" }]
  },
  getNodeValue: {
    wasmFunctionName: "_EN_getnodevalue",
    inputArgDefs: [
      { typeHint: "number" },
      { typeHint: "enum" }
      // NodeProperty enum
    ],
    outputArgDefs: [{ name: "value", type: "double" }]
  },
  setNodeValue: {
    wasmFunctionName: "_EN_setnodevalue",
    inputArgDefs: [
      { typeHint: "number" },
      { typeHint: "enum" },
      // NodeProperty enum
      { typeHint: "number" }
      // value
    ],
    outputArgDefs: []
  },
  getNodeType: {
    wasmFunctionName: "_EN_getnodetype",
    inputArgDefs: [{ typeHint: "number" }],
    // index
    outputArgDefs: [{ name: "type", type: "int" }]
  },
  setJunctionData: {
    wasmFunctionName: "_EN_setjuncdata",
    inputArgDefs: [
      { typeHint: "number" },
      // nodeIndex
      { typeHint: "number" },
      // elev
      { typeHint: "number" },
      // demand
      { typeHint: "string", isStringPtr: !0 }
      // patternId string
    ],
    outputArgDefs: []
  },
  getComment: {
    wasmFunctionName: "_EN_getcomment",
    inputArgDefs: [
      { typeHint: "enum" },
      // EN_NODE, EN_LINK, EN_TIMEPAT or EN_CURVE
      { typeHint: "number" }
      // index
    ],
    outputArgDefs: [{ name: "comment", type: "char" }]
  },
  setComment: {
    wasmFunctionName: "_EN_setcomment",
    inputArgDefs: [
      { typeHint: "enum" },
      // EN_NODE, EN_LINK, EN_TIMEPAT or EN_CURVE
      { typeHint: "number" },
      // index
      { typeHint: "string", isStringPtr: !0 }
      // index
    ],
    outputArgDefs: []
  },
  //  // --- Example Version-Gated Function ---
  //  openX: {
  //    wasmFunctionName: "_EN_openX",
  //    inputArgDefs: [{ typeHint: "number" }], // nodeIndex
  //    outputArgDefs: [{ name: "value", type: "double" }],
  //    minVersion: 20300, // Requires EPANET 2.3.0+
  //  },
  // Node Functions
  deleteNode: {
    wasmFunctionName: "_EN_deletenode",
    inputArgDefs: [
      { typeHint: "number" },
      // index
      { typeHint: "enum" }
      // actionCode (ActionCodeType enum)
    ],
    outputArgDefs: []
  },
  getNodeId: {
    wasmFunctionName: "_EN_getnodeid",
    inputArgDefs: [{ typeHint: "number" }],
    // index
    outputArgDefs: [{ name: "id", type: "char" }]
  },
  setNodeId: {
    wasmFunctionName: "_EN_setnodeid",
    inputArgDefs: [
      { typeHint: "number" },
      // index
      { typeHint: "string", isStringPtr: !0 }
      // newid
    ],
    outputArgDefs: []
  },
  setTankData: {
    wasmFunctionName: "_EN_settankdata",
    inputArgDefs: [
      { typeHint: "number" },
      // index
      { typeHint: "number" },
      // elev
      { typeHint: "number" },
      // initlvl
      { typeHint: "number" },
      // minlvl
      { typeHint: "number" },
      // maxlvl
      { typeHint: "number" },
      // diam
      { typeHint: "number" },
      // minvol
      { typeHint: "string", isStringPtr: !0 }
      // volcurve
    ],
    outputArgDefs: []
  },
  getCoordinates: {
    wasmFunctionName: "_EN_getcoord",
    inputArgDefs: [{ typeHint: "number" }],
    // index
    outputArgDefs: [
      { name: "x", type: "double" },
      { name: "y", type: "double" }
    ]
  },
  setCoordinates: {
    wasmFunctionName: "_EN_setcoord",
    inputArgDefs: [
      { typeHint: "number" },
      // index
      { typeHint: "number" },
      // x
      { typeHint: "number" }
      // y
    ],
    outputArgDefs: []
  },
  // Hydraulic Analysis Functions
  solveH: {
    wasmFunctionName: "_EN_solveH",
    inputArgDefs: [],
    outputArgDefs: []
  },
  useHydFile: {
    wasmFunctionName: "_EN_usehydfile",
    inputArgDefs: [
      { typeHint: "string", isStringPtr: !0 }
      // filename
    ],
    outputArgDefs: []
  },
  openH: {
    wasmFunctionName: "_EN_openH",
    inputArgDefs: [],
    outputArgDefs: []
  },
  initH: {
    wasmFunctionName: "_EN_initH",
    inputArgDefs: [
      { typeHint: "enum" }
      // initFlag (InitHydOption enum)
    ],
    outputArgDefs: []
  },
  runH: {
    wasmFunctionName: "_EN_runH",
    inputArgDefs: [],
    outputArgDefs: [{ name: "currentTime", type: "int" }]
  },
  nextH: {
    wasmFunctionName: "_EN_nextH",
    inputArgDefs: [],
    outputArgDefs: [{ name: "tStep", type: "int" }]
  },
  saveH: {
    wasmFunctionName: "_EN_saveH",
    inputArgDefs: [],
    outputArgDefs: []
  },
  saveHydFile: {
    wasmFunctionName: "_EN_savehydfile",
    inputArgDefs: [
      { typeHint: "string", isStringPtr: !0 }
      // filename
    ],
    outputArgDefs: []
  },
  closeH: {
    wasmFunctionName: "_EN_closeH",
    inputArgDefs: [],
    outputArgDefs: []
  },
  // Network Link Functions
  addLink: {
    wasmFunctionName: "_EN_addlink",
    inputArgDefs: [
      { typeHint: "string", isStringPtr: !0 },
      // id
      { typeHint: "enum" },
      // linkType (LinkType enum)
      { typeHint: "string", isStringPtr: !0 },
      // fromNode
      { typeHint: "string", isStringPtr: !0 }
      // toNode
    ],
    outputArgDefs: [{ name: "index", type: "int" }]
  },
  deleteLink: {
    wasmFunctionName: "_EN_deletelink",
    inputArgDefs: [
      { typeHint: "number" },
      // index
      { typeHint: "enum" }
      // actionCode (ActionCodeType enum)
    ],
    outputArgDefs: []
  },
  getLinkIndex: {
    wasmFunctionName: "_EN_getlinkindex",
    inputArgDefs: [{ typeHint: "string", isStringPtr: !0 }],
    // id
    outputArgDefs: [{ name: "index", type: "int" }]
  },
  getLinkId: {
    wasmFunctionName: "_EN_getlinkid",
    inputArgDefs: [{ typeHint: "number" }],
    // index
    outputArgDefs: [{ name: "id", type: "char" }]
  },
  setLinkId: {
    wasmFunctionName: "_EN_setlinkid",
    inputArgDefs: [
      { typeHint: "number" },
      // index
      { typeHint: "string", isStringPtr: !0 }
      // newid
    ],
    outputArgDefs: []
  },
  getLinkType: {
    wasmFunctionName: "_EN_getlinktype",
    inputArgDefs: [{ typeHint: "number" }],
    // index
    outputArgDefs: [{ name: "type", type: "int" }]
  },
  getLinkNodes: {
    wasmFunctionName: "_EN_getlinknodes",
    inputArgDefs: [{ typeHint: "number" }],
    // index
    outputArgDefs: [
      { name: "node1", type: "int" },
      { name: "node2", type: "int" }
    ]
  },
  setLinkNodes: {
    wasmFunctionName: "_EN_setlinknodes",
    inputArgDefs: [
      { typeHint: "number" },
      // index
      { typeHint: "number" },
      // node1
      { typeHint: "number" }
      // node2
    ],
    outputArgDefs: []
  },
  getLinkValue: {
    wasmFunctionName: "_EN_getlinkvalue",
    inputArgDefs: [
      { typeHint: "number" },
      // index
      { typeHint: "enum" }
      // property (LinkProperty enum)
    ],
    outputArgDefs: [{ name: "value", type: "double" }]
  },
  setLinkValue: {
    wasmFunctionName: "_EN_setlinkvalue",
    inputArgDefs: [
      { typeHint: "number" },
      // index
      { typeHint: "enum" },
      // property (LinkProperty enum)
      { typeHint: "number" }
      // value
    ],
    outputArgDefs: []
  },
  setPipeData: {
    wasmFunctionName: "_EN_setpipedata",
    inputArgDefs: [
      { typeHint: "number" },
      // index
      { typeHint: "number" },
      // length
      { typeHint: "number" },
      // diam
      { typeHint: "number" },
      // rough
      { typeHint: "number" }
      // mloss
    ],
    outputArgDefs: []
  },
  getPumpType: {
    wasmFunctionName: "_EN_getpumptype",
    inputArgDefs: [{ typeHint: "number" }],
    // index
    outputArgDefs: [{ name: "type", type: "int" }]
  },
  getHeadCurveIndex: {
    wasmFunctionName: "_EN_getheadcurveindex",
    inputArgDefs: [{ typeHint: "number" }],
    // linkIndex
    outputArgDefs: [{ name: "curveIndex", type: "int" }]
  },
  setHeadCurveIndex: {
    wasmFunctionName: "_EN_setheadcurveindex",
    inputArgDefs: [
      { typeHint: "number" },
      // linkIndex
      { typeHint: "number" }
      // curveIndex
    ],
    outputArgDefs: []
  },
  getVertexCount: {
    wasmFunctionName: "_EN_getvertexcount",
    inputArgDefs: [{ typeHint: "number" }],
    // index
    outputArgDefs: [{ name: "count", type: "int" }]
  },
  getVertex: {
    wasmFunctionName: "_EN_getvertex",
    inputArgDefs: [
      { typeHint: "number" },
      // index
      { typeHint: "number" }
      // vertex
    ],
    outputArgDefs: [
      { name: "x", type: "double" },
      { name: "y", type: "double" }
    ]
  },
  setVertices: {
    wasmFunctionName: "_EN_setvertices",
    inputArgDefs: [
      { typeHint: "number" },
      // index
      { typeHint: "double[]" },
      // x array
      { typeHint: "double[]" },
      // y array
      { typeHint: "length" }
      // count (automatically calculated from x array)
    ],
    outputArgDefs: []
  },
  // Project Functions
  getTitle: {
    wasmFunctionName: "_EN_gettitle",
    inputArgDefs: [],
    outputArgDefs: [
      { name: "line1", type: "char-title" },
      { name: "line2", type: "char-title" },
      { name: "line3", type: "char-title" }
    ]
  },
  setTitle: {
    wasmFunctionName: "_EN_settitle",
    inputArgDefs: [
      { typeHint: "string", isStringPtr: !0 },
      // line1
      { typeHint: "string", isStringPtr: !0 },
      // line2
      { typeHint: "string", isStringPtr: !0 }
      // line3
    ],
    outputArgDefs: []
  },
  saveInpFile: {
    wasmFunctionName: "_EN_saveinpfile",
    inputArgDefs: [{ typeHint: "string", isStringPtr: !0 }],
    // filename
    outputArgDefs: []
  },
  runProject: {
    wasmFunctionName: "_EN_runproject",
    inputArgDefs: [
      { typeHint: "string", isStringPtr: !0 },
      // inputFile
      { typeHint: "string", isStringPtr: !0 },
      // reportFile
      { typeHint: "string", isStringPtr: !0 }
      // outputFile
    ],
    outputArgDefs: []
  },
  // Reporting Functions
  writeLine: {
    wasmFunctionName: "_EN_writeline",
    inputArgDefs: [{ typeHint: "string", isStringPtr: !0 }],
    // line
    outputArgDefs: []
  },
  report: {
    wasmFunctionName: "_EN_report",
    inputArgDefs: [],
    outputArgDefs: []
  },
  copyReport: {
    wasmFunctionName: "_EN_copyreport",
    inputArgDefs: [{ typeHint: "string", isStringPtr: !0 }],
    // filename
    outputArgDefs: []
  },
  clearReport: {
    wasmFunctionName: "_EN_clearreport",
    inputArgDefs: [],
    outputArgDefs: []
  },
  resetReport: {
    wasmFunctionName: "_EN_resetreport",
    inputArgDefs: [],
    outputArgDefs: []
  },
  setReport: {
    wasmFunctionName: "_EN_setreport",
    inputArgDefs: [{ typeHint: "string", isStringPtr: !0 }],
    // format
    outputArgDefs: []
  },
  setStatusReport: {
    wasmFunctionName: "_EN_setstatusreport",
    inputArgDefs: [{ typeHint: "enum" }],
    // level (StatusReport enum)
    outputArgDefs: []
  },
  getStatistic: {
    wasmFunctionName: "_EN_getstatistic",
    inputArgDefs: [{ typeHint: "enum" }],
    // type (AnalysisStatistic enum)
    outputArgDefs: [{ name: "value", type: "double" }]
  },
  getResultIndex: {
    wasmFunctionName: "_EN_getresultindex",
    inputArgDefs: [
      { typeHint: "enum" },
      // type (ObjectType enum)
      { typeHint: "number" }
      // index
    ],
    outputArgDefs: [{ name: "resultIndex", type: "int" }]
  },
  // Time Pattern Functions
  addPattern: {
    wasmFunctionName: "_EN_addpattern",
    inputArgDefs: [{ typeHint: "string", isStringPtr: !0 }],
    // id
    outputArgDefs: []
  },
  deletePattern: {
    wasmFunctionName: "_EN_deletepattern",
    inputArgDefs: [{ typeHint: "number" }],
    // index
    outputArgDefs: []
  },
  getPatternIndex: {
    wasmFunctionName: "_EN_getpatternindex",
    inputArgDefs: [{ typeHint: "string", isStringPtr: !0 }],
    // id
    outputArgDefs: [{ name: "index", type: "int" }]
  },
  getPatternId: {
    wasmFunctionName: "_EN_getpatternid",
    inputArgDefs: [{ typeHint: "number" }],
    // index
    outputArgDefs: [{ name: "id", type: "char" }]
  },
  setPatternId: {
    wasmFunctionName: "_EN_setpatternid",
    inputArgDefs: [
      { typeHint: "number" },
      // index
      { typeHint: "string", isStringPtr: !0 }
      // id
    ],
    outputArgDefs: []
  },
  getPatternLength: {
    wasmFunctionName: "_EN_getpatternlen",
    inputArgDefs: [{ typeHint: "number" }],
    // index
    outputArgDefs: [{ name: "length", type: "int" }]
  },
  getPatternValue: {
    wasmFunctionName: "_EN_getpatternvalue",
    inputArgDefs: [
      { typeHint: "number" },
      // index
      { typeHint: "number" }
      // period
    ],
    outputArgDefs: [{ name: "value", type: "double" }]
  },
  setPatternValue: {
    wasmFunctionName: "_EN_setpatternvalue",
    inputArgDefs: [
      { typeHint: "number" },
      // index
      { typeHint: "number" },
      // period
      { typeHint: "number" }
      // value
    ],
    outputArgDefs: []
  },
  getAveragePatternValue: {
    wasmFunctionName: "_EN_getaveragepatternvalue",
    inputArgDefs: [{ typeHint: "number" }],
    // index
    outputArgDefs: [{ name: "value", type: "double" }]
  },
  setPattern: {
    wasmFunctionName: "_EN_setpattern",
    inputArgDefs: [
      { typeHint: "number" },
      // index
      { typeHint: "double[]" },
      // values array
      { typeHint: "length" }
      // count (automatically calculated from values array)
    ],
    outputArgDefs: []
  },
  // Water Quality Analysis Functions
  solveQ: {
    wasmFunctionName: "_EN_solveQ",
    inputArgDefs: [],
    outputArgDefs: []
  },
  openQ: {
    wasmFunctionName: "_EN_openQ",
    inputArgDefs: [],
    outputArgDefs: []
  },
  initQ: {
    wasmFunctionName: "_EN_initQ",
    inputArgDefs: [{ typeHint: "enum" }],
    // initFlag (InitHydOption enum)
    outputArgDefs: []
  },
  runQ: {
    wasmFunctionName: "_EN_runQ",
    inputArgDefs: [],
    outputArgDefs: [{ name: "currentTime", type: "int" }]
  },
  nextQ: {
    wasmFunctionName: "_EN_nextQ",
    inputArgDefs: [],
    outputArgDefs: [{ name: "tStep", type: "int" }]
  },
  stepQ: {
    wasmFunctionName: "_EN_stepQ",
    inputArgDefs: [],
    outputArgDefs: [{ name: "tStep", type: "int" }]
  },
  closeQ: {
    wasmFunctionName: "_EN_closeQ",
    inputArgDefs: [],
    outputArgDefs: []
  },
  // Analysis Options Functions
  getFlowUnits: {
    wasmFunctionName: "_EN_getflowunits",
    inputArgDefs: [],
    outputArgDefs: [{ name: "units", type: "int" }]
  },
  getOption: {
    wasmFunctionName: "_EN_getoption",
    inputArgDefs: [{ typeHint: "enum" }],
    // option (Option enum)
    outputArgDefs: [{ name: "value", type: "double" }]
  },
  getQualityInfo: {
    wasmFunctionName: "_EN_getqualinfo",
    inputArgDefs: [],
    outputArgDefs: [
      { name: "qualType", type: "int" },
      { name: "chemName", type: "char" },
      { name: "chemUnits", type: "char" },
      { name: "traceNode", type: "int" }
    ]
  },
  getQualityType: {
    wasmFunctionName: "_EN_getqualtype",
    inputArgDefs: [],
    outputArgDefs: [
      { name: "qualType", type: "int" },
      { name: "traceNode", type: "int" }
    ]
  },
  getTimeParameter: {
    wasmFunctionName: "_EN_gettimeparam",
    inputArgDefs: [{ typeHint: "enum" }],
    // param (TimeParameter enum)
    outputArgDefs: [{ name: "value", type: "int" }]
  },
  setFlowUnits: {
    wasmFunctionName: "_EN_setflowunits",
    inputArgDefs: [{ typeHint: "enum" }],
    // units (FlowUnits enum)
    outputArgDefs: []
  },
  setOption: {
    wasmFunctionName: "_EN_setoption",
    inputArgDefs: [
      { typeHint: "enum" },
      // option (Option enum)
      { typeHint: "number" }
      // value
    ],
    outputArgDefs: []
  },
  setQualityType: {
    wasmFunctionName: "_EN_setqualtype",
    inputArgDefs: [
      { typeHint: "enum" },
      // qualType (QualityType enum)
      { typeHint: "string", isStringPtr: !0 },
      // chemName
      { typeHint: "string", isStringPtr: !0 },
      // chemUnits
      { typeHint: "string", isStringPtr: !0 }
      // traceNode
    ],
    outputArgDefs: []
  },
  setTimeParameter: {
    wasmFunctionName: "_EN_settimeparam",
    inputArgDefs: [
      { typeHint: "enum" },
      // param (TimeParameter enum)
      { typeHint: "number" }
      // value
    ],
    outputArgDefs: []
  },
  // Nodal Demand Functions
  addDemand: {
    wasmFunctionName: "_EN_adddemand",
    inputArgDefs: [
      { typeHint: "number" },
      // nodeIndex
      { typeHint: "number" },
      // baseDemand
      { typeHint: "string", isStringPtr: !0 },
      // demandPattern
      { typeHint: "string", isStringPtr: !0 }
      // demandName
    ],
    outputArgDefs: []
  },
  deleteDemand: {
    wasmFunctionName: "_EN_deletedemand",
    inputArgDefs: [
      { typeHint: "number" },
      // nodeIndex
      { typeHint: "number" }
      // demandIndex
    ],
    outputArgDefs: []
  },
  getBaseDemand: {
    wasmFunctionName: "_EN_getbasedemand",
    inputArgDefs: [
      { typeHint: "number" },
      // nodeIndex
      { typeHint: "number" }
      // demandIndex
    ],
    outputArgDefs: [{ name: "baseDemand", type: "double" }]
  },
  getDemandIndex: {
    wasmFunctionName: "_EN_getdemandindex",
    inputArgDefs: [
      { typeHint: "number" },
      // nodeIndex
      { typeHint: "string", isStringPtr: !0 }
      // demandName
    ],
    outputArgDefs: [{ name: "demandIndex", type: "int" }]
  },
  getDemandModel: {
    wasmFunctionName: "_EN_getdemandmodel",
    inputArgDefs: [],
    outputArgDefs: [
      { name: "type", type: "int" },
      { name: "pmin", type: "double" },
      { name: "preq", type: "double" },
      { name: "pexp", type: "double" }
    ]
  },
  getDemandName: {
    wasmFunctionName: "_EN_getdemandname",
    inputArgDefs: [
      { typeHint: "number" },
      // nodeIndex
      { typeHint: "number" }
      // demandIndex
    ],
    outputArgDefs: [{ name: "demandName", type: "char" }]
  },
  getDemandPattern: {
    wasmFunctionName: "_EN_getdemandpattern",
    inputArgDefs: [
      { typeHint: "number" },
      // nodeIndex
      { typeHint: "number" }
      // demandIndex
    ],
    outputArgDefs: [{ name: "patternIndex", type: "int" }]
  },
  getNumberOfDemands: {
    wasmFunctionName: "_EN_getnumdemands",
    inputArgDefs: [{ typeHint: "number" }],
    // nodeIndex
    outputArgDefs: [{ name: "numDemands", type: "int" }]
  },
  setBaseDemand: {
    wasmFunctionName: "_EN_setbasedemand",
    inputArgDefs: [
      { typeHint: "number" },
      // nodeIndex
      { typeHint: "number" },
      // demandIndex
      { typeHint: "number" }
      // baseDemand
    ],
    outputArgDefs: []
  },
  setDemandModel: {
    wasmFunctionName: "_EN_setdemandmodel",
    inputArgDefs: [
      { typeHint: "enum" },
      // type (DemandModel enum)
      { typeHint: "number" },
      // pmin
      { typeHint: "number" },
      // preq
      { typeHint: "number" }
      // pexp
    ],
    outputArgDefs: []
  },
  setDemandName: {
    wasmFunctionName: "_EN_setdemandname",
    inputArgDefs: [
      { typeHint: "number" },
      // nodeIndex
      { typeHint: "number" },
      // demandIdx
      { typeHint: "string", isStringPtr: !0 }
      // demandName
    ],
    outputArgDefs: []
  },
  setDemandPattern: {
    wasmFunctionName: "_EN_setdemandpattern",
    inputArgDefs: [
      { typeHint: "number" },
      // nodeIndex
      { typeHint: "number" },
      // demandIndex
      { typeHint: "number" }
      // patIndex
    ],
    outputArgDefs: []
  },
  // Simple Control Functions
  addControl: {
    wasmFunctionName: "_EN_addcontrol",
    inputArgDefs: [
      { typeHint: "enum" },
      // type (ControlType enum)
      { typeHint: "number" },
      // linkIndex
      { typeHint: "number" },
      // setting
      { typeHint: "number" },
      // nodeIndex
      { typeHint: "number" }
      // level
    ],
    outputArgDefs: [{ name: "controlIndex", type: "int" }]
  },
  deleteControl: {
    wasmFunctionName: "_EN_deletecontrol",
    inputArgDefs: [{ typeHint: "number" }],
    // index
    outputArgDefs: []
  },
  getControl: {
    wasmFunctionName: "_EN_getcontrol",
    inputArgDefs: [{ typeHint: "number" }],
    // index
    outputArgDefs: [
      { name: "type", type: "int" },
      { name: "linkIndex", type: "int" },
      { name: "setting", type: "double" },
      { name: "nodeIndex", type: "int" },
      { name: "level", type: "double" }
    ]
  },
  setControl: {
    wasmFunctionName: "_EN_setcontrol",
    inputArgDefs: [
      { typeHint: "number" },
      // index
      { typeHint: "enum" },
      // type (ControlType enum)
      { typeHint: "number" },
      // linkIndex
      { typeHint: "number" },
      // setting
      { typeHint: "number" },
      // nodeIndex
      { typeHint: "number" }
      // level
    ],
    outputArgDefs: []
  },
  // Rule-Based Control Functions
  addRule: {
    wasmFunctionName: "_EN_addrule",
    inputArgDefs: [{ typeHint: "string", isStringPtr: !0 }],
    // rule
    outputArgDefs: []
  },
  deleteRule: {
    wasmFunctionName: "_EN_deleterule",
    inputArgDefs: [{ typeHint: "number" }],
    // index
    outputArgDefs: []
  },
  getRule: {
    wasmFunctionName: "_EN_getrule",
    inputArgDefs: [{ typeHint: "number" }],
    // index
    outputArgDefs: [
      { name: "premiseCount", type: "int" },
      { name: "thenActionCount", type: "int" },
      { name: "elseActionCount", type: "int" },
      { name: "priority", type: "double" }
    ]
  },
  getRuleId: {
    wasmFunctionName: "_EN_getruleID",
    inputArgDefs: [{ typeHint: "number" }],
    // index
    outputArgDefs: [{ name: "id", type: "char" }]
  },
  getPremise: {
    wasmFunctionName: "_EN_getpremise",
    inputArgDefs: [
      { typeHint: "number" },
      // ruleIndex
      { typeHint: "number" }
      // premiseIndex
    ],
    outputArgDefs: [
      { name: "logop", type: "int" },
      { name: "object", type: "int" },
      { name: "objIndex", type: "int" },
      { name: "variable", type: "int" },
      { name: "relop", type: "int" },
      { name: "status", type: "int" },
      { name: "value", type: "double" }
    ]
  },
  setPremise: {
    wasmFunctionName: "_EN_setpremise",
    inputArgDefs: [
      { typeHint: "number" },
      // ruleIndex
      { typeHint: "number" },
      // premiseIndex
      { typeHint: "number" },
      // logop
      { typeHint: "enum" },
      // object (RuleObject enum)
      { typeHint: "number" },
      // objIndex
      { typeHint: "enum" },
      // variable (RuleVariable enum)
      { typeHint: "enum" },
      // relop (RuleOperator enum)
      { typeHint: "enum" },
      // status (RuleStatus enum)
      { typeHint: "number" }
      // value
    ],
    outputArgDefs: []
  },
  setPremiseIndex: {
    wasmFunctionName: "_EN_setpremiseindex",
    inputArgDefs: [
      { typeHint: "number" },
      // ruleIndex
      { typeHint: "number" },
      // premiseIndex
      { typeHint: "number" }
      // objIndex
    ],
    outputArgDefs: []
  },
  setPremiseStatus: {
    wasmFunctionName: "_EN_setpremisestatus",
    inputArgDefs: [
      { typeHint: "number" },
      // ruleIndex
      { typeHint: "number" },
      // premiseIndex
      { typeHint: "enum" }
      // status (RuleStatus enum)
    ],
    outputArgDefs: []
  },
  setPremiseValue: {
    wasmFunctionName: "_EN_setpremisevalue",
    inputArgDefs: [
      { typeHint: "number" },
      // ruleIndex
      { typeHint: "number" },
      // premiseIndex
      { typeHint: "number" }
      // value
    ],
    outputArgDefs: []
  },
  getThenAction: {
    wasmFunctionName: "_EN_getthenaction",
    inputArgDefs: [
      { typeHint: "number" },
      // ruleIndex
      { typeHint: "number" }
      // actionIndex
    ],
    outputArgDefs: [
      { name: "linkIndex", type: "int" },
      { name: "status", type: "int" },
      { name: "setting", type: "double" }
    ]
  },
  setThenAction: {
    wasmFunctionName: "_EN_setthenaction",
    inputArgDefs: [
      { typeHint: "number" },
      // ruleIndex
      { typeHint: "number" },
      // actionIndex
      { typeHint: "number" },
      // linkIndex
      { typeHint: "enum" },
      // status (RuleStatus enum)
      { typeHint: "number" }
      // setting
    ],
    outputArgDefs: []
  },
  getElseAction: {
    wasmFunctionName: "_EN_getelseaction",
    inputArgDefs: [
      { typeHint: "number" },
      // ruleIndex
      { typeHint: "number" }
      // actionIndex
    ],
    outputArgDefs: [
      { name: "linkIndex", type: "int" },
      { name: "status", type: "int" },
      { name: "setting", type: "double" }
    ]
  },
  setElseAction: {
    wasmFunctionName: "_EN_setelseaction",
    inputArgDefs: [
      { typeHint: "number" },
      // ruleIndex
      { typeHint: "number" },
      // actionIndex
      { typeHint: "number" },
      // linkIndex
      { typeHint: "enum" },
      // status (RuleStatus enum)
      { typeHint: "number" }
      // setting
    ],
    outputArgDefs: []
  },
  setRulePriority: {
    wasmFunctionName: "_EN_setrulepriority",
    inputArgDefs: [
      { typeHint: "number" },
      // index
      { typeHint: "number" }
      // priority
    ],
    outputArgDefs: []
  },
  // Data Curve Functions
  addCurve: {
    wasmFunctionName: "_EN_addcurve",
    inputArgDefs: [{ typeHint: "string", isStringPtr: !0 }],
    // id
    outputArgDefs: []
  },
  deleteCurve: {
    wasmFunctionName: "_EN_deletecurve",
    inputArgDefs: [{ typeHint: "number" }],
    // index
    outputArgDefs: []
  },
  getCurveIndex: {
    wasmFunctionName: "_EN_getcurveindex",
    inputArgDefs: [{ typeHint: "string", isStringPtr: !0 }],
    // id
    outputArgDefs: [{ name: "index", type: "int" }]
  },
  getCurveId: {
    wasmFunctionName: "_EN_getcurveid",
    inputArgDefs: [{ typeHint: "number" }],
    // index
    outputArgDefs: [{ name: "id", type: "char" }]
  },
  setCurveId: {
    wasmFunctionName: "_EN_setcurveid",
    inputArgDefs: [
      { typeHint: "number" },
      // index
      { typeHint: "string", isStringPtr: !0 }
      // id
    ],
    outputArgDefs: []
  },
  getCurveLenth: {
    wasmFunctionName: "_EN_getcurvelen",
    inputArgDefs: [{ typeHint: "number" }],
    // index
    outputArgDefs: [{ name: "length", type: "int" }]
  },
  getCurveType: {
    wasmFunctionName: "_EN_getcurvetype",
    inputArgDefs: [{ typeHint: "number" }],
    // index
    outputArgDefs: [{ name: "type", type: "int" }]
  },
  getCurveValue: {
    wasmFunctionName: "_EN_getcurvevalue",
    inputArgDefs: [
      { typeHint: "number" },
      // curveIndex
      { typeHint: "number" }
      // pointIndex
    ],
    outputArgDefs: [
      { name: "x", type: "double" },
      { name: "y", type: "double" }
    ]
  },
  setCurveValue: {
    wasmFunctionName: "_EN_setcurvevalue",
    inputArgDefs: [
      { typeHint: "number" },
      // curveIndex
      { typeHint: "number" },
      // pointIndex
      { typeHint: "number" },
      // x
      { typeHint: "number" }
      // y
    ],
    outputArgDefs: []
  },
  setCurve: {
    wasmFunctionName: "_EN_setcurve",
    inputArgDefs: [
      { typeHint: "number" },
      // index
      { typeHint: "double[]" },
      // xValues array
      { typeHint: "double[]" },
      // yValues array
      { typeHint: "length" }
      // count (automatically calculated from xValues array)
    ],
    outputArgDefs: []
  }
  // ... Define ALL other EPANET functions ...
}, v = class v {
  constructor(n) {
    t(this, "_ws");
    t(this, "_EN");
    // Use the combined type EpanetModule
    t(this, "_projectHandle");
    // Assert definite assignment
    t(this, "_epanetVersionInt", -1);
    t(this, "_absoluteMinVersion", 20200);
    // --- Declare Public API Methods with '!' ---
    t(this, "getComment");
    t(this, "setComment");
    t(this, "openX");
    // ... other version-specific methods ...
    // Node Functions
    t(this, "addNode");
    t(this, "getNodeIndex");
    t(this, "getNodeValue");
    t(this, "setNodeValue");
    t(this, "setJunctionData");
    t(this, "getNodeType");
    t(this, "deleteNode");
    t(this, "getNodeId");
    t(this, "setNodeId");
    t(this, "setTankData");
    t(this, "getCoordinates");
    t(this, "setCoordinates");
    // Hydraulic Analysis Functions
    t(this, "solveH");
    t(this, "useHydFile");
    t(this, "openH");
    t(this, "initH");
    t(this, "runH");
    t(this, "nextH");
    t(this, "saveH");
    t(this, "saveHydFile");
    t(this, "closeH");
    // Network Link Functions
    t(this, "addLink");
    t(this, "deleteLink");
    t(this, "getLinkIndex");
    t(this, "getLinkId");
    t(this, "setLinkId");
    t(this, "getLinkType");
    t(this, "getLinkNodes");
    t(this, "setLinkNodes");
    t(this, "getLinkValue");
    t(this, "setLinkValue");
    t(this, "setPipeData");
    t(this, "getPumpType");
    t(this, "getHeadCurveIndex");
    t(this, "setHeadCurveIndex");
    t(this, "getVertexCount");
    t(this, "getVertex");
    t(this, "setVertices");
    // Project Functions
    t(this, "close");
    t(this, "getCount");
    t(this, "getTitle");
    t(this, "setTitle");
    t(this, "init");
    t(this, "open");
    t(this, "saveInpFile");
    t(this, "runProject");
    // Reporting Functions
    t(this, "writeLine");
    t(this, "report");
    t(this, "copyReport");
    t(this, "clearReport");
    t(this, "resetReport");
    t(this, "setReport");
    t(this, "setStatusReport");
    t(this, "getStatistic");
    t(this, "getResultIndex");
    // Time Pattern Functions
    t(this, "addPattern");
    t(this, "deletePattern");
    t(this, "getPatternIndex");
    t(this, "getPatternId");
    t(this, "setPatternId");
    t(this, "getPatternLength");
    t(this, "getPatternValue");
    t(this, "setPatternValue");
    t(this, "getAveragePatternValue");
    t(this, "setPattern");
    // Water Quality Analysis Functions
    t(this, "solveQ");
    t(this, "openQ");
    t(this, "initQ");
    t(this, "runQ");
    t(this, "nextQ");
    t(this, "stepQ");
    t(this, "closeQ");
    // Analysis Options Functions
    t(this, "getFlowUnits");
    t(this, "getOption");
    t(this, "getQualityInfo");
    t(this, "getQualityType");
    t(this, "getTimeParameter");
    t(this, "setFlowUnits");
    t(this, "setOption");
    t(this, "setQualityType");
    t(this, "setTimeParameter");
    // Nodal Demand Functions
    t(this, "addDemand");
    t(this, "deleteDemand");
    t(this, "getBaseDemand");
    t(this, "getDemandIndex");
    t(this, "getDemandModel");
    t(this, "getDemandName");
    t(this, "getDemandPattern");
    t(this, "getNumberOfDemands");
    t(this, "setBaseDemand");
    t(this, "setDemandModel");
    t(this, "setDemandName");
    t(this, "setDemandPattern");
    // Simple Control Functions
    t(this, "addControl");
    t(this, "deleteControl");
    t(this, "getControl");
    t(this, "setControl");
    // Rule-Based Control Functions
    t(this, "addRule");
    t(this, "deleteRule");
    t(this, "getRule");
    t(this, "getRuleId");
    t(this, "getPremise");
    t(this, "setPremise");
    t(this, "setPremiseIndex");
    t(this, "setPremiseStatus");
    t(this, "setPremiseValue");
    t(this, "getThenAction");
    t(this, "setThenAction");
    t(this, "getElseAction");
    t(this, "setElseAction");
    t(this, "setRulePriority");
    // Data Curve Functions
    t(this, "addCurve");
    t(this, "deleteCurve");
    t(this, "getCurveIndex");
    t(this, "getCurveId");
    t(this, "setCurveId");
    t(this, "getCurveLenth");
    t(this, "getCurveType");
    t(this, "getCurveValue");
    t(this, "setCurveValue");
    t(this, "setCurve");
    this._ws = n, this._ws.isLoaded ? this._initializeProject() : (this._EN = void 0, this._createDummyMethods());
  }
  // Complex Functions
  getCurve(n) {
    if (!this._EN)
      throw new Error(
        "EPANET engine not loaded. Call loadModule() on the Workspace first."
      );
    const r = this.getCurveLenth(n), u = this._EN._malloc(32), s = this._EN._malloc(r * 8), i = this._EN._malloc(r * 8), a = this._EN._malloc(4);
    try {
      const o = this._EN._EN_getcurve(
        this._projectHandle,
        n,
        u,
        a,
        s,
        i
      );
      this._checkError(o);
      const d = this._EN.UTF8ToString(u), f = new Array(r), g = new Array(r);
      for (let p = 0; p < r; p++)
        f[p] = this._EN.getValue(s + p * 8, "double"), g[p] = this._EN.getValue(i + p * 8, "double");
      return {
        id: d,
        x: f,
        y: g
      };
    } finally {
      this._EN._free(u), this._EN._free(s), this._EN._free(i), this._EN._free(a);
    }
  }
  setLinkType(n, r, u) {
    if (!this._EN)
      throw new Error(
        "EPANET engine not loaded. Call loadModule() on the Workspace first."
      );
    const s = this._EN._malloc(4);
    try {
      this._EN.HEAP32[s >> 2] = n;
      const i = this._EN._EN_setlinktype(
        this._projectHandle,
        s,
        r,
        u
      );
      return this._checkError(i), this._EN.getValue(s, "i32");
    } finally {
      this._EN._free(s);
    }
  }
  _initializeProject() {
    this._EN = this._ws.instance, this._projectHandle = this._createProject(), this._epanetVersionInt = this._getAndVerifyEpanetVersion(), this._buildApiMethods(), v._finalizer.register(this, {
      projectHandle: this._projectHandle,
      enInstance: this._EN
    });
  }
  _createDummyMethods() {
    const n = (r) => (...u) => {
      if (this._ws.isLoaded && (this._EN = this._ws.instance, this._ws.isLoaded))
        return this._initializeProject(), this[r](...u);
      throw new Error(
        "EPANET engine not loaded. Call loadModule() on the Workspace first."
      );
    };
    for (const r in h)
      Object.prototype.hasOwnProperty.call(h, r) && (this[r] = n(r));
  }
  _createProject() {
    if (!this._EN)
      throw new Error(
        "EPANET engine not loaded. Call loadModule() on the Workspace first."
      );
    const n = "_EN_createproject", r = this._EN[n];
    if (typeof r != "function")
      throw new Error(
        `EPANET function '${n}' not found in WASM module.`
      );
    const u = this._EN._malloc(4);
    if (u === 0)
      throw new Error("Memory allocation failed for project creation.");
    let s = 0;
    try {
      const i = r(u);
      if (i !== 0) {
        const a = this._ws.getError ? this._ws.getError(i) : `error code ${i}`;
        throw new Error(`Failed to create EPANET project: ${a}`);
      }
      s = this._EN.getValue(u, "i32");
    } finally {
      this._EN._free(u);
    }
    if (s === 0)
      throw new Error(
        "EPANET project creation succeeded but returned a null handle."
      );
    return s;
  }
  _getAndVerifyEpanetVersion() {
    if (!this._EN)
      throw new Error(
        "EPANET engine not loaded. Call loadModule() on the Workspace first."
      );
    const n = "_EN_getversion", r = this._EN[n];
    if (typeof r != "function")
      throw new Error(
        `WASM module missing '${n}'. Min required v${this._formatVersionInt(
          this._absoluteMinVersion
        )}.`
      );
    let u = 0, s = -1;
    try {
      if (u = this._EN._malloc(4), u === 0)
        throw new Error("Memory allocation failed for version check.");
      const i = r(u);
      if (i !== 0)
        throw new Error(`'${n}' failed with code ${i}.`);
      s = this._EN.getValue(u, "i32");
    } catch (i) {
      const a = i instanceof Error ? i.message : String(i);
      throw new Error(`Failed to determine EPANET version: ${a}`);
    } finally {
      if (u !== 0)
        try {
          this._EN._free(u);
        } catch {
        }
    }
    if (s < this._absoluteMinVersion)
      throw new Error(
        `EPANET Version Too Low: Loaded v${this._formatVersionInt(
          s
        )}, requires v${this._formatVersionInt(this._absoluteMinVersion)}.`
      );
    return s;
  }
  _formatVersionInt(n) {
    if (n < 0) return "Unknown";
    const r = Math.floor(n / 1e4), u = Math.floor(n % 1e4 / 100), s = n % 100;
    return `${r}.${u}.${s}`;
  }
  // --- API Builder ---
  _buildApiMethods() {
    for (const n in h)
      if (Object.prototype.hasOwnProperty.call(h, n)) {
        const r = h[n];
        this[n] = this._createApiMethod(
          r,
          n
        );
      }
  }
  // --- API Method Factory (Handles projectHandle and input strings) ---
  _createApiMethod(n, r) {
    if (!this._EN)
      throw new Error(
        "EPANET engine not loaded. Call loadModule() on the Workspace first."
      );
    const u = this._EN, s = n.wasmFunctionName;
    return (...i) => {
      var p, H, w;
      if (n.minVersion && this._epanetVersionInt < n.minVersion)
        throw new Error(
          `Method '${r}' requires EPANET v${this._formatVersionInt(
            n.minVersion
          )}, loaded is v${this._formatVersionInt(this._epanetVersionInt)}.`
        );
      const a = u[s];
      if (typeof a != "function")
        throw new Error(
          `EPANET function '${s}' (for method '${r}') not found.`
        );
      let o = [], d = [], f = [];
      const g = [this._projectHandle];
      try {
        const D = ((p = n.inputArgDefs) == null ? void 0 : p.filter((m) => m.typeHint !== "length").length) ?? 0;
        if (i.length !== D)
          throw new Error(
            `Method '${r}' expected ${D} arguments, received ${i.length}.`
          );
        const c = (H = n.inputArgDefs) == null ? void 0 : H.map(
          (m, l) => m.typeHint === "double[]" ? i[l] : null
        ).filter((m) => m !== null);
        if (c.length > 1) {
          const m = c[0].length, l = c.filter(
            (E) => E.length !== m
          );
          if (l.length > 0)
            throw new Error(
              `All array arguments must have the same length. First array length: ${m}, mismatched arrays: ${l.map((E) => E.length).join(", ")}`
            );
        }
        (w = n.inputArgDefs) == null || w.forEach((m, l) => {
          const E = i[l];
          if (m.isStringPtr && typeof E == "string") {
            const A = u.lengthBytesUTF8(E) + 1, N = u._malloc(A);
            if (N === 0)
              throw new Error(
                `Malloc failed for input string arg ${l} in ${r}`
              );
            u.stringToUTF8(E, N, A), d.push(N), g.push(N);
          } else if (m.typeHint === "double[]") {
            if (!Array.isArray(E))
              throw new Error(`Argument ${l} must be an array`);
            const A = this._allocateMemoryForArray(E);
            f.push(A), g.push(A);
          } else if (m.typeHint === "length") {
            const A = n.inputArgDefs.findIndex(
              (P) => P.typeHint === "double[]"
            );
            if (A === -1)
              throw new Error(
                `No array found for length parameter at index ${l}`
              );
            const N = i[A];
            if (!Array.isArray(N))
              throw new Error(
                `Length parameter at index ${l} requires a corresponding array`
              );
            g.push(N.length);
          } else
            g.push(E);
        }), n.outputArgDefs.length > 0 && (o = this._allocateMemory(
          n.outputArgDefs.map((m) => m.type)
        ), g.push(...o));
        const _ = a.apply(u, g);
        this._checkError(_);
        let C = [];
        if (n.outputArgDefs.length > 0 && (C = o.map(
          (m, l) => this._getValue(m, n.outputArgDefs[l].type)
        ), o = []), n.outputArgDefs.length === 0) return;
        if (n.outputArgDefs.length === 1)
          return C[0];
        const I = {};
        return n.outputArgDefs.forEach((m, l) => {
          I[m.name] = C[l];
        }), I;
      } catch (D) {
        throw o.forEach((c) => {
          if (c !== 0)
            try {
              u._free(c);
            } catch {
            }
        }), d.forEach((c) => {
          if (c !== 0)
            try {
              u._free(c);
            } catch {
            }
        }), f.forEach((c) => {
          if (c !== 0)
            try {
              u._free(c);
            } catch {
            }
        }), D;
      } finally {
        d.forEach((D) => {
          D !== 0 && u._free(D);
        }), f.forEach((D) => {
          D !== 0 && u._free(D);
        });
      }
    };
  }
  // --- Memory/Error Helpers ---
  _allocateMemory(n) {
    if (!this._EN)
      throw new Error(
        "EPANET engine not loaded. Call loadModule() on the Workspace first."
      );
    const r = this._EN;
    return n.map((u) => {
      let s;
      switch (u) {
        case "char":
          s = 32;
          break;
        case "char-title":
          s = 80;
          break;
        case "int":
          s = 4;
          break;
        case "double":
        default:
          s = 8;
          break;
      }
      const i = r._malloc(s);
      if (i === 0)
        throw new Error(`Failed to allocate ${s} bytes for type ${u}`);
      return i;
    });
  }
  _allocateMemoryForArray(n) {
    if (!this._EN)
      throw new Error(
        "EPANET engine not loaded. Call loadModule() on the Workspace first."
      );
    const r = this._EN, u = new Float64Array(n), s = u.length * u.BYTES_PER_ELEMENT, i = r._malloc(s);
    if (i === 0)
      throw new Error(
        `Malloc failed allocating ${s} bytes for array.`
      );
    return r.HEAPF64.set(u, i / u.BYTES_PER_ELEMENT), i;
  }
  _getValue(n, r) {
    if (!this._EN)
      throw new Error(
        "EPANET engine not loaded. Call loadModule() on the Workspace first."
      );
    const u = this._EN;
    let s;
    if (n === 0)
      throw new Error(`Attempted to read from null pointer for type ${r}`);
    try {
      if (r === "char" || r === "char-title")
        s = u.UTF8ToString(n);
      else {
        const i = r === "int" ? "i32" : "double";
        s = u.getValue(n, i);
      }
    } catch (i) {
      const a = i instanceof Error ? i.message : String(i);
      throw new Error(
        `Failed to get value for type ${r} from pointer ${n}: ${a}`
      );
    } finally {
      if (n !== 0)
        try {
          u._free(n);
        } catch (i) {
          console.error(`Error freeing pointer ${n}: ${i}`);
        }
    }
    return s;
  }
  _checkError(n) {
    if (n === 0) return;
    const r = this._ws.getError(n);
    if (n < 100) {
      console.warn(`epanet-js (Warning ${n}): ${r}`);
      return;
    }
    throw new Error(`EPANET Error ${n}: ${r}`);
  }
  // Add _allocateMemoryForArray if needed
};
t(v, "_finalizer", new FinalizationRegistry(
  (n) => {
    const { projectHandle: r, enInstance: u } = n;
    if (r !== 0) {
      const s = "_EN_deleteproject", i = u[s];
      if (typeof i == "function")
        try {
          const a = i(r);
          a !== 0 && console.warn(
            `Finalizer: _EN_deleteproject returned code ${a} for handle ${r}`
          );
        } catch (a) {
          console.warn(
            `Error during finalization cleanup for handle ${r}: ${a}`
          );
        }
      else
        console.warn(
          `Finalizer: Function ${s} not found in EpanetModule instance during cleanup for handle ${r}.`
        );
    } else
      console.warn(
        "Finalizer callback invoked for an already zeroed handle."
      );
  }
));
let M = v;
var Q = /* @__PURE__ */ ((e) => (e[e.Unconditional = 0] = "Unconditional", e[e.Conditional = 1] = "Conditional", e))(Q || {}), B = /* @__PURE__ */ ((e) => (e[e.Iterations = 0] = "Iterations", e[e.RelativeError = 1] = "RelativeError", e[e.MaxHeadError = 2] = "MaxHeadError", e[e.MaxFlowChange = 3] = "MaxFlowChange", e[e.MassBalance = 4] = "MassBalance", e[e.DeficientNodes = 5] = "DeficientNodes", e[e.DemandReduction = 6] = "DemandReduction", e))(B || {}), G = /* @__PURE__ */ ((e) => (e[e.LowLevel = 0] = "LowLevel", e[e.HiLevel = 1] = "HiLevel", e[e.Timer = 2] = "Timer", e[e.TimeOfDay = 3] = "TimeOfDay", e))(G || {}), W = /* @__PURE__ */ ((e) => (e[e.NodeCount = 0] = "NodeCount", e[e.TankCount = 1] = "TankCount", e[e.LinkCount = 2] = "LinkCount", e[e.PatCount = 3] = "PatCount", e[e.CurveCount = 4] = "CurveCount", e[e.ControlCount = 5] = "ControlCount", e[e.RuleCount = 6] = "RuleCount", e))(W || {}), q = /* @__PURE__ */ ((e) => (e[e.VolumeCurve = 0] = "VolumeCurve", e[e.PumpCurve = 1] = "PumpCurve", e[e.EfficCurve = 2] = "EfficCurve", e[e.HlossCurve = 3] = "HlossCurve", e[e.GenericCurve = 4] = "GenericCurve", e))(q || {}), L = /* @__PURE__ */ ((e) => (e[e.DDA = 0] = "DDA", e[e.PDA = 1] = "PDA", e))(L || {}), j = /* @__PURE__ */ ((e) => (e[e.CFS = 0] = "CFS", e[e.GPM = 1] = "GPM", e[e.MGD = 2] = "MGD", e[e.IMGD = 3] = "IMGD", e[e.AFD = 4] = "AFD", e[e.LPS = 5] = "LPS", e[e.LPM = 6] = "LPM", e[e.MLD = 7] = "MLD", e[e.CMH = 8] = "CMH", e[e.CMD = 9] = "CMD", e))(j || {}), z = /* @__PURE__ */ ((e) => (e[e.HW = 0] = "HW", e[e.DW = 1] = "DW", e[e.CM = 2] = "CM", e))(z || {}), K = /* @__PURE__ */ ((e) => (e[e.NoSave = 0] = "NoSave", e[e.Save = 1] = "Save", e[e.InitFlow = 10] = "InitFlow", e[e.SaveAndInit = 11] = "SaveAndInit", e))(K || {}), J = /* @__PURE__ */ ((e) => (e[e.Diameter = 0] = "Diameter", e[e.Length = 1] = "Length", e[e.Roughness = 2] = "Roughness", e[e.MinorLoss = 3] = "MinorLoss", e[e.InitStatus = 4] = "InitStatus", e[e.InitSetting = 5] = "InitSetting", e[e.KBulk = 6] = "KBulk", e[e.KWall = 7] = "KWall", e[e.Flow = 8] = "Flow", e[e.Velocity = 9] = "Velocity", e[e.Headloss = 10] = "Headloss", e[e.Status = 11] = "Status", e[e.Setting = 12] = "Setting", e[e.Energy = 13] = "Energy", e[e.LinkQual = 14] = "LinkQual", e[e.LinkPattern = 15] = "LinkPattern", e[e.PumpState = 16] = "PumpState", e[e.PumpEffic = 17] = "PumpEffic", e[e.PumpPower = 18] = "PumpPower", e[e.PumpHCurve = 19] = "PumpHCurve", e[e.PumpECurve = 20] = "PumpECurve", e[e.PumpECost = 21] = "PumpECost", e[e.PumpEPat = 22] = "PumpEPat", e))(J || {}), R = /* @__PURE__ */ ((e) => (e[e.Closed = 0] = "Closed", e[e.Open = 1] = "Open", e))(R || {}), X = /* @__PURE__ */ ((e) => (e[e.CVPipe = 0] = "CVPipe", e[e.Pipe = 1] = "Pipe", e[e.Pump = 2] = "Pump", e[e.PRV = 3] = "PRV", e[e.PSV = 4] = "PSV", e[e.PBV = 5] = "PBV", e[e.FCV = 6] = "FCV", e[e.TCV = 7] = "TCV", e[e.GPV = 8] = "GPV", e))(X || {}), Y = /* @__PURE__ */ ((e) => (e[e.Mix1 = 0] = "Mix1", e[e.Mix2 = 1] = "Mix2", e[e.FIFO = 2] = "FIFO", e[e.LIFO = 3] = "LIFO", e))(Y || {}), Z = /* @__PURE__ */ ((e) => (e[e.Elevation = 0] = "Elevation", e[e.BaseDemand = 1] = "BaseDemand", e[e.Pattern = 2] = "Pattern", e[e.Emitter = 3] = "Emitter", e[e.Initqual = 4] = "Initqual", e[e.SourceQual = 5] = "SourceQual", e[e.SourcePat = 6] = "SourcePat", e[e.SourceType = 7] = "SourceType", e[e.TankLevel = 8] = "TankLevel", e[e.Demand = 9] = "Demand", e[e.Head = 10] = "Head", e[e.Pressure = 11] = "Pressure", e[e.Quality = 12] = "Quality", e[e.SourceMass = 13] = "SourceMass", e[e.InitVolume = 14] = "InitVolume", e[e.MixModel = 15] = "MixModel", e[e.MixZoneVol = 16] = "MixZoneVol", e[e.TankDiam = 17] = "TankDiam", e[e.MinVolume = 18] = "MinVolume", e[e.VolCurve = 19] = "VolCurve", e[e.MinLevel = 20] = "MinLevel", e[e.MaxLevel = 21] = "MaxLevel", e[e.MixFraction = 22] = "MixFraction", e[e.TankKBulk = 23] = "TankKBulk", e[e.TankVolume = 24] = "TankVolume", e[e.MaxVolume = 25] = "MaxVolume", e[e.CanOverFlow = 26] = "CanOverFlow", e[e.DemandDeficit = 27] = "DemandDeficit", e))(Z || {}), y = /* @__PURE__ */ ((e) => (e[e.Junction = 0] = "Junction", e[e.Reservoir = 1] = "Reservoir", e[e.Tank = 2] = "Tank", e))(y || {}), U = /* @__PURE__ */ ((e) => (e[e.Node = 0] = "Node", e[e.Link = 1] = "Link", e[e.TimePat = 2] = "TimePat", e[e.Curve = 3] = "Curve", e[e.Control = 4] = "Control", e[e.Rule = 5] = "Rule", e))(U || {}), T = /* @__PURE__ */ ((e) => (e[e.Trials = 0] = "Trials", e[e.Accuracy = 1] = "Accuracy", e[e.Tolerance = 2] = "Tolerance", e[e.Emitexpon = 3] = "Emitexpon", e[e.DemandMult = 4] = "DemandMult", e[e.HeadError = 5] = "HeadError", e[e.FlowChange = 6] = "FlowChange", e[e.HeadlossForm = 7] = "HeadlossForm", e[e.GlobalEffic = 8] = "GlobalEffic", e[e.GlobalPrice = 9] = "GlobalPrice", e[e.GlobalPattern = 10] = "GlobalPattern", e[e.DemandCharge = 11] = "DemandCharge", e[e.SpGravity = 12] = "SpGravity", e[e.SpViscos = 13] = "SpViscos", e[e.Unbalanced = 14] = "Unbalanced", e[e.CheckFreq = 15] = "CheckFreq", e[e.MaxCheck = 16] = "MaxCheck", e[e.DampLimit = 17] = "DampLimit", e[e.SpDiffus = 18] = "SpDiffus", e[e.BulkOrder = 19] = "BulkOrder", e[e.WallOrder = 20] = "WallOrder", e[e.TankOrder = 21] = "TankOrder", e[e.ConcenLimit = 22] = "ConcenLimit", e))(T || {}), O = /* @__PURE__ */ ((e) => (e[e.PumpXHead = 0] = "PumpXHead", e[e.PumpClosed = 2] = "PumpClosed", e[e.PumpOpen = 3] = "PumpOpen", e[e.PumpXFlow = 5] = "PumpXFlow", e))(O || {}), ee = /* @__PURE__ */ ((e) => (e[e.ConstHP = 0] = "ConstHP", e[e.PowerFunc = 1] = "PowerFunc", e[e.Custom = 2] = "Custom", e[e.NoCurve = 3] = "NoCurve", e))(ee || {}), te = /* @__PURE__ */ ((e) => (e[e.None = 0] = "None", e[e.Chem = 1] = "Chem", e[e.Age = 2] = "Age", e[e.Trace = 3] = "Trace", e))(te || {}), ne = /* @__PURE__ */ ((e) => (e[e.Node = 6] = "Node", e[e.Link = 7] = "Link", e[e.System = 8] = "System", e))(ne || {}), re = /* @__PURE__ */ ((e) => (e[e.EqualTo = 0] = "EqualTo", e[e.NotEqualTo = 1] = "NotEqualTo", e[e.LessOrEqualTo = 2] = "LessOrEqualTo", e[e.GreaterOrEqualTo = 3] = "GreaterOrEqualTo", e[e.LessThan = 4] = "LessThan", e[e.GreaterThan = 5] = "GreaterThan", e[e.Is = 6] = "Is", e[e.Not = 7] = "Not", e[e.Below = 8] = "Below", e[e.Above = 9] = "Above", e))(re || {}), ue = /* @__PURE__ */ ((e) => (e[e.IsOpen = 1] = "IsOpen", e[e.IsClosed = 2] = "IsClosed", e[e.IsActive = 3] = "IsActive", e))(ue || {}), se = /* @__PURE__ */ ((e) => (e[e.Demand = 0] = "Demand", e[e.Head = 1] = "Head", e[e.Grade = 2] = "Grade", e[e.Level = 3] = "Level", e[e.Pressure = 4] = "Pressure", e[e.Flow = 5] = "Flow", e[e.Status = 6] = "Status", e[e.Setting = 7] = "Setting", e[e.Power = 8] = "Power", e[e.Time = 9] = "Time", e[e.ClockTime = 10] = "ClockTime", e[e.FillTime = 11] = "FillTime", e[e.DrainTime = 12] = "DrainTime", e))(se || {}), ie = /* @__PURE__ */ ((e) => (e[e.MaxId = 31] = "MaxId", e[e.MaxMsg = 255] = "MaxMsg", e))(ie || {}), ae = /* @__PURE__ */ ((e) => (e[e.Concen = 0] = "Concen", e[e.Mass = 1] = "Mass", e[e.SetPoint = 2] = "SetPoint", e[e.FlowPaced = 3] = "FlowPaced", e))(ae || {}), oe = /* @__PURE__ */ ((e) => (e[e.Series = 0] = "Series", e[e.Average = 1] = "Average", e[e.Minimum = 2] = "Minimum", e[e.Maximum = 3] = "Maximum", e[e.Range = 4] = "Range", e))(oe || {}), me = /* @__PURE__ */ ((e) => (e[e.NoReport = 0] = "NoReport", e[e.NormalReport = 1] = "NormalReport", e[e.FullReport = 2] = "FullReport", e))(me || {}), ge = /* @__PURE__ */ ((e) => (e[e.Duration = 0] = "Duration", e[e.HydStep = 1] = "HydStep", e[e.QualStep = 2] = "QualStep", e[e.PatternStep = 3] = "PatternStep", e[e.PatternStart = 4] = "PatternStart", e[e.ReportStep = 5] = "ReportStep", e[e.ReportStart = 6] = "ReportStart", e[e.RuleStep = 7] = "RuleStep", e[e.Statistic = 8] = "Statistic", e[e.Periods = 9] = "Periods", e[e.StartTime = 10] = "StartTime", e[e.HTime = 11] = "HTime", e[e.QTime = 12] = "QTime", e[e.HaltFlag = 13] = "HaltFlag", e[e.NextEvent = 14] = "NextEvent", e[e.NextEventTank = 15] = "NextEventTank", e))(ge || {});
const F = 32;
function Ne(e) {
  const n = new DataView(e.buffer), r = {
    nodeCount: n.getInt32(8, !0),
    resAndTankCount: n.getInt32(12, !0),
    linkCount: n.getInt32(16, !0),
    pumpCount: n.getInt32(20, !0),
    valveCount: n.getInt32(24, !0),
    reportingPeriods: n.getInt32(e.byteLength - 12, !0)
  }, u = 884, s = u + F * r.nodeCount, i = u + 32 * r.nodeCount + 40 * r.linkCount, a = u + 32 * r.nodeCount + 44 * r.linkCount, o = u + 36 * r.nodeCount + 52 * r.linkCount + 8 * r.resAndTankCount + 28 * r.pumpCount + 4, d = x(u, r.nodeCount, n), f = pe(
    a,
    r.nodeCount,
    r.resAndTankCount,
    n
  ), g = x(s, r.linkCount, n), p = le(i, r.linkCount, n), H = [...Array(r.nodeCount)].map((c, _) => fe(
    r,
    o,
    _,
    n,
    d[_],
    f[_]
  )), w = [...Array(r.linkCount)].map((c, _) => de(
    r,
    o,
    _,
    n,
    g[_],
    p[_]
  ));
  return {
    prolog: r,
    results: {
      nodes: H,
      links: w
    }
  };
}
const x = (e, n, r) => {
  const u = [];
  return b(n, (s) => {
    const i = r.buffer.slice(
      e + F * s,
      e + F * s + F
    );
    u.push(_e(i));
  }), u;
}, pe = (e, n, r, u) => {
  const s = [], [i, a] = ce(
    e,
    r,
    u
  );
  return b(n, (o) => {
    if (!i.includes(o)) {
      s.push(y.Junction);
      return;
    }
    if (a[i.indexOf(o)] === 0) {
      s.push(y.Reservoir);
      return;
    }
    s.push(y.Tank);
  }), s;
}, ce = (e, n, r) => {
  const u = [], s = [], i = e + 4 * n;
  return b(n, (a) => {
    const o = r.getInt32(e + 4 * a, !0);
    u.push(o - 1), s.push(r.getFloat32(i + 4 * a, !0));
  }), [u, s];
}, le = (e, n, r) => {
  const u = [];
  return b(n, (s) => {
    const i = e + 4 * s, a = r.getInt32(i, !0);
    u.push(a);
  }), u;
}, fe = (e, n, r, u, s, i) => {
  const a = {
    id: s,
    type: i,
    demand: [],
    head: [],
    pressure: [],
    waterQuality: []
  };
  return [
    "demand",
    "head",
    "pressure",
    "waterQuality"
  ].reduce((d, f, g) => ({
    ...d,
    [f]: S(
      e,
      n,
      !0,
      r,
      g
    ).map((p) => u.getFloat32(p, !0))
  }), a);
}, de = (e, n, r, u, s, i) => {
  const a = {
    id: s,
    type: i,
    flow: [],
    velocity: [],
    headloss: [],
    avgWaterQuality: [],
    status: [],
    setting: [],
    reactionRate: [],
    friction: []
  };
  return [
    "flow",
    "velocity",
    "headloss",
    "avgWaterQuality",
    "status",
    "setting",
    "reactionRate",
    "friction"
  ].reduce((d, f, g) => ({
    ...d,
    [f]: S(
      e,
      n,
      !1,
      r,
      g
    ).map((p) => u.getFloat32(p, !0))
  }), a);
}, S = (e, n, r, u, s) => {
  const i = r ? 0 : 16 * e.nodeCount, a = r ? e.nodeCount : e.linkCount, o = 16 * e.nodeCount + 32 * e.linkCount;
  return [...Array(e.reportingPeriods)].map(
    (f, g) => n + o * g + i + 4 * u + 4 * s * a
  );
}, b = (e, n) => {
  for (let r = 0; r < e; ++r)
    n(r);
}, _e = (e) => {
  const n = new Uint8Array(e), r = Array.from(n).filter((u) => u > 0);
  return String.fromCharCode.apply(null, r);
};
export {
  Q as ActionCodeType,
  B as AnalysisStatistic,
  G as ControlType,
  W as CountType,
  q as CurveType,
  L as DemandModel,
  j as FlowUnits,
  z as HeadLossType,
  K as InitHydOption,
  J as LinkProperty,
  R as LinkStatusType,
  X as LinkType,
  Y as MixingModel,
  Z as NodeProperty,
  y as NodeType,
  U as ObjectType,
  T as Option,
  M as Project,
  O as PumpStateType,
  ee as PumpType,
  te as QualityType,
  ne as RuleObject,
  re as RuleOperator,
  ue as RuleStatus,
  se as RuleVariable,
  ie as SizeLimits,
  ae as SourceType,
  oe as StatisticType,
  me as StatusReport,
  ge as TimeParameter,
  Ae as Workspace,
  Ne as readBinary
};
